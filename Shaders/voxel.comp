#version 450
//below three can be adjusted by cpu program
#define CHUNK_WIDTH 16
#define CHUNK_HEIGHT 256
#define CHUNK_DEPTH 16

//note: maximum chunk depth will be 128 voxels and minimum will be such that 128 / chunk depth will not be greater than chunk width
#define LOCAL_SIZE_X (128 / CHUNK_DEPTH)
#define LOCAL_SIZE_Y 1
#define LOCAL_SIZE_Z CHUNK_DEPTH

layout (local_size_x = LOCAL_SIZE_X, local_size_y = LOCAL_SIZE_Y, local_size_z = LOCAL_SIZE_Z) in;

layout(set = 0, binding = 0) uniform GlobalData{
    mat4 proj;
    mat4 view;
    mat4 projView;
	vec4 fovY_aspectRatio_zNear_zFar;
    vec4 cameraPos_time;
    vec4 cameraDir;
} viewInfo;

layout(std430, set = 1, binding = 0) readonly buffer VoxelData{
	uint array[];    //voxel material id
} voxels;

layout(std140, set = 2, binding = 0) buffer VoxelDrawCount{
    uint vertexCount;
	uint instanceCount;
	uint firstVertex;
	uint firstInstance;
} voxelDrawCount;

layout(std140, set = 2, binding = 1) writeonly buffer VoxelDrawBuffer{
    uvec4 array[];
} drawPositionMat;

uint getVoxelIndex(uvec3 voxelID){
    uint chunkIndex = gl_WorkGroupID.z + gl_WorkGroupID.x * gl_NumWorkGroups.z; 
    uint voxelIndex = voxelID.x + voxelID.z * CHUNK_WIDTH + voxelID.y * CHUNK_DEPTH * CHUNK_WIDTH;
    return chunkIndex * CHUNK_WIDTH * CHUNK_HEIGHT * CHUNK_DEPTH + voxelIndex;
}

uint getVoxelMatWithinChunk(ivec3 voxelID){
    int isWithinChunkBounds = int(!(
        any(lessThan(voxelID, ivec3(0, 0, 0))) || 
        any(greaterThanEqual(voxelID, ivec3(CHUNK_WIDTH, CHUNK_HEIGHT, CHUNK_DEPTH)))
    ));
    //if out of chunk bounds return zero, else return material
    // return isWithinChunkBounds * voxels.array[isWithinChunkBounds * getVoxelIndex(voxelID)];

    return isWithinChunkBounds * uint(voxelID.y > int(sin(viewInfo.cameraPos_time.w) * 64 * sin(voxelID.x + gl_WorkGroupID.x) * cos(voxelID.z + gl_WorkGroupID.z * CHUNK_DEPTH)));
}

void main(){
    uint xID  = gl_LocalInvocationID.x * (CHUNK_WIDTH / LOCAL_SIZE_X);
    uint xLimit = xID + (CHUNK_WIDTH / LOCAL_SIZE_X);
    for(xID; xID < xLimit; xID++){
        uvec3 ID = uvec3(
            xID,
            gl_WorkGroupID.y,
            gl_LocalInvocationID.z
        );

        uint trueMatID = getVoxelMatWithinChunk(ivec3(ID));
        
        ivec3 iID = ivec3(ID);
        // front back left right top bottom
        uint faces[6] = {
            getVoxelMatWithinChunk(iID + ivec3(0, 0, -1)),
            getVoxelMatWithinChunk(iID + ivec3(0, 0, 1)),

            getVoxelMatWithinChunk(iID + ivec3(-1, 0, 0)),
            getVoxelMatWithinChunk(iID + ivec3(1, 0, 0)),
            
            getVoxelMatWithinChunk(iID + ivec3(0, 1, 0)),
            getVoxelMatWithinChunk(iID + ivec3(0, -1, 0)),
        };

        int mask = 0;
        for(int i = 0; i < 6; i++){
            //if voxel neighbouring that face is not empty (material is 0) then mask it
            mask |= (int(faces[i] != 0) << i);
        }
        
        uvec3 position =  gl_WorkGroupID * uvec3(CHUNK_WIDTH, 0, CHUNK_DEPTH) + ID;

        uint currMatID = gl_WorkGroupID.z + gl_WorkGroupID.x * gl_NumWorkGroups.z;

        uint encodedMaterialID = bitfieldInsert(
            bitfieldInsert(uint(0), mask, (32 - 6), 6),
            currMatID,
            0,
            (32 - 6)
        );


        vec3 cameraPos = viewInfo.cameraPos_time.xyz;
        vec3 voxelPos = position;
        float angle = acos(dot(normalize(cameraPos - voxelPos), viewInfo.cameraDir.xyz));
        float dist = distance(voxelPos, cameraPos);
        bool isCameraVisible = (
            angle < viewInfo.fovY_aspectRatio_zNear_zFar.x
            && 
            (
                dist > viewInfo.fovY_aspectRatio_zNear_zFar.z
                &&
                dist < viewInfo.fovY_aspectRatio_zNear_zFar.w
            )
        );        

        // * viewInfo.fovY_aspectRatio_zNear_zFar.y);
        // bool isCameraVisible = (angle < radians(100.0));
        // && (dist > viewInfo.fovY_aspectRatio_zNear_zFar.z && dist < viewInfo.fovY_aspectRatio_zNear_zFar.w);

        bool isVisible = ((trueMatID != 0) && (mask != 0x3f)) && (isCameraVisible);
        // bool isVisible = ((currMatID != 0));
        // bool isVisible = true;

        uint index = atomicAdd(voxelDrawCount.instanceCount, uint(isVisible));
        if(isVisible){
            drawPositionMat.array[index] = uvec4(position, encodedMaterialID);
        }
    }
}

/*
Next steps:
    1) cull back faces (enable and check)
    2) cull out of frustum cone in this voxel.comp shader only
        by getting camera pos and fov, calculate angle between voxel position and camera pos
    3) create new compute pipeline to modify the voxel world before this one runs
        you can make it so that it modifies the next frame's world while this one is rendering
    4) motion blur


    1) use square as primitive and do backface culling in this shader
    2) have seperate draw queues for front, back, left, right, top, bottom and draw the one in dir of cam first
    3)

    */