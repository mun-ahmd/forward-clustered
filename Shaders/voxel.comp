#version 450
//below three can be adjusted by cpu program
#define CHUNK_WIDTH 16
#define CHUNK_HEIGHT 256
#define CHUNK_DEPTH 16

//note: maximum chunk width will be 128 voxels and minimum will be such that 128 / chunk width will not be greater than chunk depth
#define LOCAL_SIZE_X CHUNK_WIDTH
#define LOCAL_SIZE_Y 1
#define LOCAL_SIZE_Z (128 / CHUNK_WIDTH)

layout (local_size_x = LOCAL_SIZE_X, local_size_y = LOCAL_SIZE_Y, local_size_z = LOCAL_SIZE_Z) in;

layout(std430, set = 2, binding = 0) readonly buffer VoxelData{
	int array[];    //voxel material id
} voxels;

layout(std140, set = 3, binding = 0) buffer VoxelDrawCount{
    int count;
} voxelDrawCount;

layout(std140, set = 3, binding = 1) writeonly buffer VoxelDrawBuffer{
    ivec4 array[];
} drawPositionMat;

uint getVoxelIndex(ivec3 voxelID){
    uint chunkIndex = gl_WorkGroupID.x + gl_WorkGroupID.z * gl_NumWorkGroups.x; 
    uint voxelIndex = voxelID.x + voxelID.z * CHUNK_WIDTH + voxelID.y * CHUNK_DEPTH * CHUNK_WIDTH;
    return chunkIndex * CHUNK_WIDTH * CHUNK_HEIGHT * CHUNK_DEPTH + voxelIndex;
}

int getVoxelMatWithinChunk(ivec3 voxelID){
    int isWithinChunkBounds = int(!(
        any(lessThan(voxelID, ivec3(0, 0, 0))) || 
        any(greaterThan(voxelID, ivec3(CHUNK_WIDTH, CHUNK_HEIGHT, CHUNK_DEPTH)))
    ));
    //if out of chunk bounds return zero, else return material
    return isWithinChunkBounds * voxels.array[isWithinChunkBounds * getVoxelIndex(voxelID)];
}

int getMask(out int currMatID){
    ivec3 ID = ivec3(
        gl_LocalInvocationID.x,
        gl_WorkGroupID.y / (CHUNK_DEPTH / LOCAL_SIZE_Z),
        gl_LocalInvocationID.z + (gl_WorkGroupID % (CHUNK_DEPTH / LOCAL_SIZE_Z)) * gl_WorkGroupSize.z
    );

    currMatID = voxels.array[getVoxelIndex(ID)];
    // front back left right top bottom
    int faces[6] = {
        getVoxelMatWithinChunk(ID + ivec3(0, 0, -1)),
        getVoxelMatWithinChunk(ID + ivec3(0, 0, 1)),

        getVoxelMatWithinChunk(ID + ivec3(-1, 0, 0)),
        getVoxelMatWithinChunk(ID + ivec3(1, 0, 0)),
        
        getVoxelMatWithinChunk(ID + ivec3(0, 1, 0)),
        getVoxelMatWithinChunk(ID + ivec3(0, -1, 0)),
    };

    int mask = 0;
    for(int i = 0; i < 6; i++){
        //if voxel neighbouring that face is not empty (material is 0) then mask it
        mask |= (int(faces[i] != 0) << i);
    }

    return 0;
}

void main(){
    ivec3 ID = ivec3(
        gl_LocalInvocationID.x,
        gl_WorkGroupID.y / (CHUNK_DEPTH / LOCAL_SIZE_Z),
        gl_LocalInvocationID.z + (gl_WorkGroupID % (CHUNK_DEPTH / LOCAL_SIZE_Z)) * gl_WorkGroupSize.z
    );

    int currMatID = voxels.array[getVoxelIndex(ID)];
    // front back left right top bottom
    int faces[6] = {
        getVoxelMatWithinChunk(ID + ivec3(0, 0, -1)),
        getVoxelMatWithinChunk(ID + ivec3(0, 0, 1)),

        getVoxelMatWithinChunk(ID + ivec3(-1, 0, 0)),
        getVoxelMatWithinChunk(ID + ivec3(1, 0, 0)),
        
        getVoxelMatWithinChunk(ID + ivec3(0, 1, 0)),
        getVoxelMatWithinChunk(ID + ivec3(0, -1, 0)),
    };

    int mask = 0;
    for(int i = 0; i < 6; i++){
        //if voxel neighbouring that face is not empty (material is 0) then mask it
        mask |= (int(faces[i] != 0) << i);
    }
    
    ivec3 position =  (ivec3(gl_WorkGroupID) - ivec3(gl_NumWorkGroups/2)) * ivec3(CHUNK_WIDTH, 0, CHUNK_DEPTH);
    position += (ivec3(ID) - ivec3(CHUNK_WIDTH, CHUNK_HEIGHT, CHUNK_DEPTH)/2);

    int encodedMaterialID = mask << (32 - 6);
    encodedMaterialID |= currMatID & ~(0x3f << (32 - 6));
    
    bool isVisible = ((currMatID != 0) && (mask != 0x3f));
    int index = atomicAdd(voxelDrawCount.count, int(isVisible));
    if(isVisible){
        drawPositionMat.array[index] = ivec4(position, encodedMaterialID);
    }
}