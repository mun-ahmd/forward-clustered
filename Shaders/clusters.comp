#version 450
layout (local_size_x = 128, local_size_y = 1, local_size_z = 1) in;

struct AABB{
    vec4 minPoint;
    vec4 maxPoint;
};

// layout (std430, set = 1, binding = 1) buffer clusterAABB{
//     AABB clusters[];
// };

struct PL{
	vec4 color;
	vec4 position_radius;
};

struct ClusterLight{
    uint offset;
    uint count;
};

layout( push_constant ) uniform constants{
    vec4 zBounds;
} PC;

layout(set = 0, binding = 0) uniform Matrices{
    mat4 proj;
    mat4 view;
    mat4 projView;
    mat4 invProj;
    mat4 invView;
} matrices;

layout(set = 1, binding = 0) readonly buffer LightsCount{
	int val;
} lightsCount;

layout(set = 1, binding = 1) readonly buffer LightsData{
	PL arr[];
} lights;

layout(set = 2, binding = 0) buffer LightIndexCount{
    int count;
} lightIndicesCount;

layout(std430, set = 2, binding = 1) writeonly buffer LightIndex{
    int indices[];
} lightIndices;

layout(std430, set = 2, binding = 2) writeonly buffer ClusterLights{
    ClusterLight clusters[];
} clusterLights;

vec3 clipCoordsForIndex(uvec2 index){
    //index ranges from [0, localSize]
    vec2 unit = 1/vec2(gl_NumWorkGroups.xy);
    vec2 coords = unit * index;
    coords = coords * 2.0 - 1.0;
    return vec3(coords, 0.0);
}

vec3 clipToView(vec3 clip){
    //todo
    vec4 res = inverse(matrices.proj) * vec4(clip, 1.0);
    res /= res.w;
    return res.xyz;
}

bool testSphereVsAABB(vec4 center_radius, AABB aabb){
    float dist = 0.0;
    center_radius.xyz = (matrices.view * vec4(center_radius.xyz, 1)).xyz;
    for(int i = 0; i < 3; ++i){
        float dist_dim = max(max(aabb.minPoint[i] - center_radius[i], center_radius[i] - aabb.maxPoint[i]), 0.0);
        dist += dist_dim * dist_dim;
    }
    return dist <= (center_radius.w * center_radius.w);
}

AABB findAABB(vec3 minViewSpace, vec3 maxViewSpace, float tileNear, float tileFar){
    vec3 minPointNear = minViewSpace * tileNear;
    vec3 minPointFar  = minViewSpace * tileFar;
    vec3 maxPointNear = maxViewSpace * tileNear;
    vec3 maxPointFar = maxViewSpace * tileFar;
    AABB aabb;
    aabb.minPoint = vec4(min(min(minPointNear, minPointFar),min(maxPointNear, maxPointFar)), 1);
    aabb.maxPoint = vec4(max(max(minPointNear, minPointFar),max(maxPointNear, maxPointFar)), 1);
    return aabb;
}

shared int totalLightsInCluster;
shared int baseOffset;

void main(){
    atomicExchange(baseOffset, -1);
    atomicExchange(totalLightsInCluster, 0);
    uvec2 index = gl_WorkGroupID.xy;
    AABB currAABB;
    // Near and far values of the cluster in view space
    float zNear = PC.zBounds[0];
    float zFar = PC.zBounds[1];
    float zFOverzN = zFar / zNear;
    float tileNear  =  pow(zFOverzN, gl_WorkGroupID.z/float(gl_NumWorkGroups.z));
    float tileFar   =  pow(zFOverzN, (gl_WorkGroupID.z + 1) /float(gl_NumWorkGroups.z));

    // currAABB.minPoint = clipToView(clipCoordsForIndex(index)) * tileNear;
    // currAABB.maxPoint = clipToView(clipCoordsForIndex(index + 1)) * tileFar;
    
    currAABB = findAABB(clipToView(clipCoordsForIndex(index)), clipToView(clipCoordsForIndex(index + 1)), tileNear, tileFar);

    // currAABB.minPoint *= tileNear / currAABB.minPoint.z;
    // currAABB.maxPoint *= tileFar / currAABB.maxPoint.z;

    uvec3 clusterIndex = gl_WorkGroupID * uvec3(
        gl_NumWorkGroups.y * gl_NumWorkGroups.z,
        gl_NumWorkGroups.z,
        1
    );

    uint numLights = lightsCount.val;
    uint batch_size = (numLights + gl_WorkGroupSize.x - 1) / gl_WorkGroupSize.x;

    uint visibleLights[100];
    int visibleLightsCount = 0;

    uint i = gl_LocalInvocationIndex * batch_size;
    uint limit = min((gl_LocalInvocationIndex + 1) * batch_size, numLights);
    for(i; i < limit; i++){
        if(testSphereVsAABB(lights.arr[i].position_radius, currAABB)){
            visibleLights[visibleLightsCount] = i;
            visibleLightsCount += 1;
        }
    }

    barrier();
    int secondaryOffset = atomicAdd(totalLightsInCluster, visibleLightsCount);
    //if base offset is equal to -1 it has not been initialized
    int baseOffsetVal = atomicCompSwap(baseOffset, -1, 2147483647);
    int isOffsetInit =  int(baseOffsetVal != -1);
    //if base offset is initialized, add zero to the main counter, else add total lights in cluster
    barrier();
    int offset = atomicAdd(lightIndicesCount.count, totalLightsInCluster * (1 - isOffsetInit));
    atomicMin(baseOffset, offset);
    barrier();
    //now final offset value is equal to baseoffset + secondaryOffset
    offset = baseOffset + secondaryOffset;

    ClusterLight lightRange;
    lightRange.offset = baseOffset;
    lightRange.count = totalLightsInCluster;

    for(i = 0; i < visibleLightsCount; ++i){
        lightIndices.indices[offset + i] = secondaryOffset; 
    }
    clusterLights.clusters[clusterIndex.x + clusterIndex.y + clusterIndex.z] = lightRange;
}