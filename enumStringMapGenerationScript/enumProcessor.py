import os
import sys
from typing import List, Dict
import random
import pprint

def removalPrefixFromTypename(typename : str) -> str:
    if not typename:
        print("Warning : Empty typename : removing no prefix")
        return ""
    
    if typename.lower().endswith("flagbits"):
        #it is flag bit type
        if "FlagBits" not in typename:
            print(f'Warning : Improperly formed FlagBits type : {typename}')
        else:
            typename = typename.removesuffix("FlagBits")

    prefix = typename[0].upper()

    for c in typename[1::]:
        if c.isupper():
            prefix += '_'
        prefix += c.upper()
    
    prefix += '_'
    
    return prefix

def removalSubstringsFromTypename(typename : str) -> List[str]:    
    if typename.lower().endswith("flagbits"):
        #it is flag bit type
        if "FlagBits" not in typename:
            print(f'Warning : Improperly formed FlagBits type : {typename}')
        else:
            return ["_BIT", "_FLAG_BITS_"]
    
    return []

def snakeToCamel(snake : str) -> str:
    camel = ""
    isNextCap = False
    for c in snake:
        if c == '_':
            isNextCap = True
        else:
            if isNextCap:
                camel += c.upper()
                isNextCap = False
            else:
                camel += c.lower()
    return camel

def processEnumsFile(typename : str, filepath : str) -> Dict[str, str]:
    enums = ''
    with open(filepath, 'r') as file:
        enums = file.read()

    prefix = removalPrefixFromTypename(typename)
    removalSubstrings = removalSubstringsFromTypename(typename)

    enums = [x.strip().split('=')[0].strip() for x in enums.split(',')]
    
    enumFromName = {}

    for enum in enums:
        name = enum.removeprefix(prefix)
        for substr in removalSubstrings:
            name = name.replace(substr, '')
        name = snakeToCamel(name)

        while name in enumFromName:
            print(f"Warning name collision : between enums : {enum} and {enumFromName[name]}")
            name += str(random.randint(100,999))

        enumFromName[name] = enum

    return enumFromName

def generateCppEnumMapValue(enumFromName : Dict[str, str]) -> str:
    output = []
    for name, enumName in enumFromName.items():
        if name.strip() == "":
            continue
        output.append(f'\t{{"{name}", {enumName}}},')

    #removing comma from after last item
    output[-1] = output[-1][0:-1]
    
    output.insert(0, "{")
    output.append("}")

    return "\n".join(output)

def getCppMapName(keyType : str, valType : str) -> str:
    return f'std::unordered_map<{keyType}, {valType}>'

def chooseCppGetterFuncForType(typename : str) -> str:
    if typename.lower().endswith("flagbits"):
        #it is flag bit type
        if "FlagBits" not in typename:
            print(f'Warning : Improperly formed FlagBits type : {typename}')
        else:
            return 'getBitFlagsFromString'
    return 'getEnumFromString'

def generateCppGetFunction(typename : str, mapName : str) -> str:
    typeShorthand = typename.removeprefix('Vk').replace('FlagBits', 'Flags').strip()
    typeShorthand = typeShorthand[0].lower() + typeShorthand[1::]
    if not typeShorthand:
        print(f"Error generating cpp function for type : {typename}")
        sys.exit(2)
    return (
f"""
inline {typename.replace('FlagBits', 'Flags')} {typeShorthand}FromString(std::string enumName) {{
    return {chooseCppGetterFuncForType(typename)}({mapName}, enumName);
}}
""".strip()
    )

def compileCppCodeSegments(code : List[str]) -> str:
    compiledCode = "\n\t".join((line.replace('\n', '\n\t') for line in code))
    return (
f"""
#pragma once

/*
    * THIS IS AN AUTOGENERATED FILE
    * GENERATED BY enumStringMapGenerationScript/enumProcessor.py
    * Refer to below maps to see enum names as strings
    * Refer to EnumStringConversionBase.hpp for how to use 
*/

#include <unordered_map>
#include <iostream>
#include <assert.h>
#include <string>
#include <vulkan/vulkan.hpp>
#include "EnumStringConversionBase.hpp"

namespace Rendering {{
    {compiledCode}
}}
""".strip()
    )


def generateCppCode(enumsFromTypename : Dict[str, Dict[str, str]]) -> str:
    code : List[str] = []

    for typename, enumFromName in enumsFromTypename.items():
        mapObjectName = typename.strip() + 'Map'
        
        code.append(
            f"inline static {getCppMapName('std::string', typename.replace('FlagBits', 'Flags'))} {mapObjectName} = {generateCppEnumMapValue(enumFromName)};"
        )

        code.append(
            generateCppGetFunction(typename, mapObjectName)
        )

    return compileCppCodeSegments(code)


if __name__ == "__main__":
    if len(sys.argv) < 3 or not os.path.isdir(sys.argv[1]):
        print(
f"""
Help Page:
    python {os.path.relpath(__file__)} <output directory> <output filename>
    
    Example Usage:
        python {os.path.relpath(__file__)} ../cppSrc/ enumsFromString.hpp
"""
        )
        sys.exit(0)
    
    outputFile = os.path.join(sys.argv[1], sys.argv[2])

    enumsList : Dict[str, Dict[str, str]] = {}
    enumDir = "enums"
    for path in os.listdir(enumDir):
        path = os.path.join(enumDir, path)
        if not os.path.isfile(path):
            continue
        
        filename = os.path.basename(path)
        splitname = filename.split('.')
        
        if len(splitname) > 2:
            print('Could not process type: ' + filename + 'at ' + path)
            continue

        typename = splitname[0]
        
        if typename in enumsList:
            print(f'Error : {typename} matched to two input files :\nnew : {pprint.pformat(processEnumsFile(typename, path))} \n\nexisting : {pprint.pformat(enumsList[typename])}')
            sys.exit(1)

        enumsList[typename] = processEnumsFile(typename, path)

    cppOutput = generateCppCode(enumsList)
    
    with open(outputFile, 'w') as file:
        file.write(cppOutput)
    
    print(f'Successfully output generated code to {outputFile}')