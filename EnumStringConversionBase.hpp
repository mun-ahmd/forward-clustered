#pragma once
#include <unordered_map>
#include <string>

/*
	Code generated by python script into file "EnumsFromStrings.hpp"
		is dependent on this file
*/

/*
	getEnumFromString simply looks for the provided string and matches an enum
		to be used for regular enums		
*/
template<typename T>
T getEnumFromString(const std::unordered_map<std::string, T>& map, std::string key) {
	auto value = map.find(key);
	if (value != map.end()) {
		//mapping found
		return value->second;
	}
	else {
		std::cerr << "Could not find matching " << typeid(T).name() << " for the string: " << key << std::endl;
		assert(false);
		return (T)(0);
	}
}

/*
	getBitFlagsFromString parses input string into multiple enum names all seperated by underscore
		example : for strA_strB_strC it will return (enumA | enumB | enumC)
	it should be used for enums that are bitfields
*/
template<typename T>
T getBitFlagsFromString(const std::unordered_map<std::string, T>& map, std::string multikey) {
	uint32_t substrStart = 0;
	T flags = 0;
	for (uint64_t i = 0; i < multikey.size(); i++) {
		if (multikey[i] == '_') {
			flags |= getEnumFromString(map, multikey.substr(substrStart, i - substrStart));
			substrStart = i + 1;
		}
	}
	return flags;
}
